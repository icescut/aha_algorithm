/****************************************************************************
 * File name    : bomb_man_enumerate.c
 * Author       : Alan Liang
 * Description  : 《啊哈，算法》炸弹人，枚举实现
 *                  # 墙
 *                  G 敌人
 *                  . 平地
 * History      :
 *                v0.1  Alan        2018/11/08 建立文件
 ****************************************************************************/

#include <stdio.h>

#define MAX_ROW 50
#define MAX_COL 50

// 边界(含)
int bound_left = 1;
int bound_right = 11;
int bound_top = 1;
int bound_bottom = 11;

int main(void)
{
    // 此处可以优化为读文件
    // 初始化地图
    int sum, max_sum = 0;        // 消灭敌人数
    int x, y;
    int prow, pcol;
    char map[MAX_ROW][MAX_COL] = {
    //    0   1   2   3   4   5   6   7   8   9   10  11  12
        {'#','#','#','#','#','#','#','#','#','#','#','#','#'}, // 0
        {'#','G','G','.','G','G','G','#','G','G','G','.','#'}, // 1
        {'#','#','#','.','#','G','#','G','#','G','#','G','#'}, // 2
        {'#','.','.','.','.','.','.','.','#','.','.','G','#'}, // 3
        {'#','G','#','.','#','#','#','.','#','G','#','G','#'}, // 4
        {'#','G','G','.','G','G','G','.','#','.','G','G','#'}, // 5
        {'#','G','#','.','#','G','#','.','#','.','#',' ','#'}, // 6
        {'#','#','G','.','.','.','G','.','.','.','.','.','#'}, // 7
        {'#','G','#','.','#','G','#','#','#','.','#','G','#'}, // 8
        {'#','.','.','.','G','#','G','G','G','.','G','G','#'}, // 9
        {'#','G','#','.','#','G','#','G','#','.','#','G','#'}, // 10
        {'#','G','G','.','G','G','G','#','G','.','G','G','#'}, // 11
        {'#','#','#','#','#','#','#','#','#','#','#','#','#'}, // 12
    };

    // 遍历所有行列，外墙除外
    for (int i = bound_top; i <= bound_bottom; ++i)
    {
        for (int j = bound_left; j <= bound_right; ++j)
        {
            // 如果为平地
            if(map[i][j] == '.')
            {
                sum = 0;

                // 向上寻找
                x = i; 
                y = j;

                while(map[x][y] != '#')
                {
                    if(map[x][y] == 'G')
                        ++sum;
                    --x;
                }

                // 向下寻找
                x = i; 
                y = j;

                while(map[x][y] != '#')
                {
                    if(map[x][y] == 'G')
                        ++sum;
                    ++x;
                }

                // 向左寻找
                x = i; 
                y = j;

                while(map[x][y] != '#')
                {
                    if(map[x][y] == 'G')
                        ++sum;
                    --y;
                }

                // 向右寻找
                x = i; 
                y = j;

                while(map[x][y] != '#')
                {
                    if(map[x][y] == 'G')
                        ++sum;
                    ++y;
                }

                // 如果大于前面记录的最大，更新最大和行列
                if(sum > max_sum)
                {
                    max_sum = sum;
                    prow = i;
                    pcol = j;
                }
            }
        }
    }
    printf("将炸弹放置在(%d,%d)，最多可以消灭%d个敌人\n",prow,pcol,max_sum);
    return 0;
}
