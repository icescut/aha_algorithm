/****************************************************************************
 * File name    : bomb_man_enumerate.c
 * Author       : Alan Liang
 * Description  : 《啊哈，算法》炸弹人，枚举实现
 *                  # 墙
 *                  G 敌人
 *                  . 平地
 * History      :
 *                v0.1  Alan        2018/11/08 建立文件
 ****************************************************************************/

#include <stdio.h>

int main(void)
{
    // 此处可以优化为读文件
    // 初始化地图
    int row = 13;
    int col = 13;
    int sum, max_sum = 0;        // 消灭敌人数
    int x, y;
    int prow, pcol;
    char map[13][13] = {
        {'#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','G','G','.','G','G','G','#','G','G','G','.','#'},
        {'#','#','#','.','#','G','#','G','#','G','#','G','#'},
        {'#','.','.','.','.','.','.','.','#','.','.','G','#'},
        {'#','G','#','.','#','#','#','.','#','G','#','G','#'},
        {'#','G','G','.','G','G','G','.','#','.','G','G','#'},
        {'#','G','#','.','#','G','#','.','#','.','#','#','#'},
        {'#','#','G','.','.','.','G','.','.','.','.','.','#'},
        {'#','G','#','.','#','G','#','#','#','.','#','G','#'},
        {'#','.','.','.','G','#','G','G','G','.','G','G','#'},
        {'#','G','#','.','#','G','#','G','#','.','#','G','#'},
        {'#','G','G','.','G','G','G','#','G','.','G','G','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#'},
    };

    // 遍历所有行列，外墙除外
    for (int i = 1; i < row-1; ++i)
    {
        for (int j = 1; j < col-1; ++j)
        {
            // 如果为平地
            if(map[i][j] == '.')
            {
                sum = 0;

                // 向上寻找
                x = i; 
                y = j;

                while(map[x][y] != '#')
                {
                    if(map[x][y] == 'G')
                        ++sum;
                    --x;
                }

                // 向下寻找
                x = i; 
                y = j;

                while(map[x][y] != '#')
                {
                    if(map[x][y] == 'G')
                        ++sum;
                    ++x;
                }

                // 向左寻找
                x = i; 
                y = j;

                while(map[x][y] != '#')
                {
                    if(map[x][y] == 'G')
                        ++sum;
                    --y;
                }

                // 向右寻找
                x = i; 
                y = j;

                while(map[x][y] != '#')
                {
                    if(map[x][y] == 'G')
                        ++sum;
                    ++y;
                }

                // 如果大于前面记录的最大，更新最大和行列
                if(sum > max_sum)
                {
                    max_sum = sum;
                    prow = i;
                    pcol = j;
                }
            }
        }
    }
    printf("将炸弹放置在(%d,%d)，最多可以消灭%d个敌人\n",prow,pcol,max_sum);
    return 0;
}
